Subject: [PATCH] EHCI: Add high-bandwidth isochronous endpoint support

Implement proper support for USB 2.0 high-bandwidth isochronous endpoints
(e.g., webcams at higher resolutions) which can transfer up to 3 packets
per microframe.

Changes:
1. Parse wMaxPacketSize correctly: bits 10:0 = base packet size,
   bits 12:11 = additional transactions per microframe (mult)

2. Program iTD transaction slots correctly for high-bandwidth:
   - Each iTD has 8 transaction slots
   - For mult=3, we use 3 slots per microframe (2-3 microframes per iTD)
   - Each slot transfers up to basePacketSize bytes

3. Add 64-bit addressing support detection and usage in iTD buffer pointers
   for systems with >4GB RAM

4. Fix iTD buffer_phy[2] Multi field programming to use correct mult value

5. Implement CancelQueuedIsochronousTransfers() properly:
   - Safely unlink iTDs from the frame list
   - Free resources correctly
   - Call callbacks appropriately

6. Fix FinishIsochronousTransfers() safety issues:
   - Validate last_token before array access
   - Save prev pointer before unlinking
   - Handle NULL itd entries

7. Fix ReadIsochronousDescriptorChain() for high-bandwidth:
   - Group transactions by mult value when reading back data
   - Handle packet descriptors correctly for multi-transaction packets

8. Implement LightReset() for controller recovery

9. Implement NotifyPipeChange() for interrupt pipes:
   - Create persistent queue heads for interrupt pipes
   - Handle USB_CHANGE_DESTROYED to clean up properly
   - Handle USB_CHANGE_PIPE_POLICY_CHANGED

10. Optimize InterruptPollThread() to reduce CPU when idle

11. Add safety checks in UnlinkITDescriptors()

These changes enable USB Video Class (UVC) webcams to stream at higher
resolutions (720p, 1080p) which require high-bandwidth isochronous endpoints.

Signed-off-by: Haiku Developer <developer@haiku-os.org>
---
 src/add-ons/kernel/busses/usb/ehci.cpp         | 450 ++++++++++++++++++-------
 src/add-ons/kernel/busses/usb/ehci.h           |   3 +
 src/add-ons/kernel/busses/usb/ehci_hardware.h  |   1 +
 3 files changed, 340 insertions(+), 114 deletions(-)

diff --git a/src/add-ons/kernel/busses/usb/ehci.cpp b/src/add-ons/kernel/busses/usb/ehci.cpp
index 2ad68ba4..8d20122e 100644
--- a/src/add-ons/kernel/busses/usb/ehci.cpp
+++ b/src/add-ons/kernel/busses/usb/ehci.cpp
@@ -355,7 +355,8 @@ EHCI::EHCI(pci_info *info, pci_device_module_info* pci, pci_device* device, Stac
 		fPortSuspendChange(0),
 		fInterruptPollThread(-1),
 		fIRQ(0),
-		fUseMSI(false)
+		fUseMSI(false),
+		fSupports64Bit(false)
 {
 	// Create a lock for the isochronous transfer list
 	mutex_init(&fIsochronousLock, "EHCI isochronous lock");
@@ -454,10 +455,16 @@ EHCI::EHCI(pci_info *info, pci_device_module_info* pci, pci_device* device, Stac
 	TRACE("capability parameters: 0x%08" B_PRIx32 "\n",
 		ReadCapReg32(EHCI_HCCPARAMS));

-	if (EHCI_HCCPARAMS_FRAME_CACHE(ReadCapReg32(EHCI_HCCPARAMS)))
+	uint32 hccParams = ReadCapReg32(EHCI_HCCPARAMS);
+	if (EHCI_HCCPARAMS_FRAME_CACHE(hccParams))
 		fThreshold = 2 + 8;
 	else
-		fThreshold = 2 + EHCI_HCCPARAMS_IPT(ReadCapReg32(EHCI_HCCPARAMS));
+		fThreshold = 2 + EHCI_HCCPARAMS_IPT(hccParams);
+
+	// Check for 64-bit addressing capability
+	fSupports64Bit = (hccParams & EHCI_HCCPARAMS_64BIT) != 0;
+	TRACE_ALWAYS("controller %s 64-bit addressing\n",
+		fSupports64Bit ? "supports" : "does not support");

 	// read port count from capability register
 	fPortCount = ReadCapReg32(EHCI_HCSPARAMS) & 0x0f;
@@ -1167,9 +1174,20 @@ EHCI::SubmitIsochronous(Transfer *transfer)
 	packetSize /= isochronousData->packet_count;
 	uint16 currentFrame;

-	if (packetSize > pipe->MaxPacketSize()) {
-		TRACE_ERROR(
-			"isochronous packetSize is bigger than pipe MaxPacketSize\n");
+	// Extract high-bandwidth parameters from wMaxPacketSize
+	// USB 2.0 spec: bits 10:0 = max packet size, bits 12:11 = additional transactions
+	uint16 rawMaxPacketSize = pipe->MaxPacketSize();
+	uint16 basePacketSize = rawMaxPacketSize & 0x7ff;
+	uint8 mult = ((rawMaxPacketSize >> 11) & 0x3) + 1;
+	size_t maxBytesPerMicroframe = basePacketSize * mult;
+
+	TRACE("isochronous high-bandwidth: raw=0x%04x base=%d mult=%d max_per_uframe=%zu\n",
+		rawMaxPacketSize, basePacketSize, mult, maxBytesPerMicroframe);
+
+	if (packetSize > maxBytesPerMicroframe) {
+		TRACE_ERROR("isochronous packetSize %zu is bigger than max bytes per "
+			"microframe %zu (base=%d, mult=%d)\n",
+			packetSize, maxBytesPerMicroframe, basePacketSize, mult);
 		return B_BAD_VALUE;
 	}

@@ -1246,49 +1264,88 @@ EHCI::SubmitIsochronous(Transfer *transfer)

 	phys_addr_t currentPhy = bufferPhy;
 	uint32 frameCount = 0;
+
+	// For high-bandwidth endpoints (mult > 1), we need to program multiple
+	// transaction slots per microframe. Each iTD has 8 transaction slots,
+	// so we can fit (8 / mult) microframes per iTD.
+	// Each transaction can transfer at most basePacketSize bytes.
+	uint32 microframesPerItd = 8 / mult;
+
+	TRACE("isochronous high-bandwidth: mult=%d, microframesPerItd=%d, "
+		"basePacketSize=%d\n", mult, microframesPerItd, basePacketSize);
+
 	while (dataLength > 0) {
 		ehci_itd* itd = CreateItdDescriptor();
 		isoRequest[itdIndex++] = itd;
 		uint16 pg = 0;
 		itd->buffer_phy[pg] = currentPhy & 0xfffff000;
+		// Set extended (64-bit) buffer pointer if supported and needed
+		if (fSupports64Bit)
+			itd->ext_buffer_phy[pg] = currentPhy >> 32;
 		uint32 offset = currentPhy & 0xfff;
 		TRACE("isochronous created itd, filling it with phy %" B_PRIxPHYSADDR
 			"\n", currentPhy);
-		for (int32 i = 0; i < 8 && dataLength > 0; i++) {
-			size_t length = min_c(dataLength, packetSize);
-			itd->token[i] = (EHCI_ITD_STATUS_ACTIVE << EHCI_ITD_STATUS_SHIFT)
-				| (length << EHCI_ITD_TLENGTH_SHIFT) | (pg << EHCI_ITD_PG_SHIFT)
-				| (offset << EHCI_ITD_TOFFSET_SHIFT);
-			itd->last_token = i;
-			TRACE("isochronous filled slot %" B_PRId32 " 0x%" B_PRIx32 "\n", i,
-				itd->token[i]);
-			dataLength -= length;
-			offset += length;
-			if (dataLength > 0 && offset > 0xfff) {
-				offset -= B_PAGE_SIZE;
-				currentPhy += B_PAGE_SIZE;
-				itd->buffer_phy[pg + 1] = currentPhy & 0xfffff000;
-				pg++;
+
+		int32 slot = 0;
+		// Process microframes (each microframe uses 'mult' transaction slots)
+		for (uint32 uframe = 0; uframe < microframesPerItd && dataLength > 0; uframe++) {
+			// For each microframe, program 'mult' transactions
+			size_t microframeDataRemaining = min_c(dataLength, packetSize);
+
+			for (uint8 t = 0; t < mult && microframeDataRemaining > 0; t++) {
+				// Each transaction transfers at most basePacketSize bytes
+				size_t length = min_c(microframeDataRemaining, (size_t)basePacketSize);
+
+				itd->token[slot] = (EHCI_ITD_STATUS_ACTIVE << EHCI_ITD_STATUS_SHIFT)
+					| (length << EHCI_ITD_TLENGTH_SHIFT) | (pg << EHCI_ITD_PG_SHIFT)
+					| (offset << EHCI_ITD_TOFFSET_SHIFT);
+				itd->last_token = slot;
+
+				TRACE("isochronous filled slot %d (uframe=%d, t=%d) 0x%" B_PRIx32
+					" (len=%zu, pg=%d, off=%u)\n", slot, uframe, t, itd->token[slot],
+					length, pg, offset);
+
+				microframeDataRemaining -= length;
+				dataLength -= length;
+				offset += length;
+
+				if (dataLength > 0 && offset > 0xfff) {
+					offset -= B_PAGE_SIZE;
+					currentPhy += B_PAGE_SIZE;
+					pg++;
+					if (pg < 7) {
+						itd->buffer_phy[pg] = currentPhy & 0xfffff000;
+						// Set extended buffer pointer for next page
+						if (fSupports64Bit)
+							itd->ext_buffer_phy[pg] = currentPhy >> 32;
+					}
+				}
+
+				slot++;
 			}
+
+			// Set IOC on the last transaction of this iTD if we're done
 			if (dataLength <= 0)
-				itd->token[i] |= EHCI_ITD_IOC;
+				itd->token[itd->last_token] |= EHCI_ITD_IOC;
 		}

 		currentPhy += (offset & 0xfff) - (currentPhy & 0xfff);

+		// Set endpoint and device address in buffer_phy[0]
 		itd->buffer_phy[0]
 			|= (pipe->EndpointAddress() << EHCI_ITD_ENDPOINT_SHIFT)
 				| (pipe->DeviceAddress() << EHCI_ITD_ADDRESS_SHIFT);
+		// Set MaxPacketSize (base size only) and direction in buffer_phy[1]
 		itd->buffer_phy[1]
-			|= (pipe->MaxPacketSize() & EHCI_ITD_MAXPACKETSIZE_MASK)
+			|= (basePacketSize & EHCI_ITD_MAXPACKETSIZE_MASK)
 				| (directionIn << EHCI_ITD_DIR_SHIFT);
+		// Set Multi (transaction count) in buffer_phy[2]
 		itd->buffer_phy[2]
-			|= ((((pipe->MaxPacketSize() >> EHCI_ITD_MAXPACKETSIZE_LENGTH) + 1)
-				& EHCI_ITD_MUL_MASK) << EHCI_ITD_MUL_SHIFT);
+			|= (mult & EHCI_ITD_MUL_MASK) << EHCI_ITD_MUL_SHIFT;

 		TRACE("isochronous filled itd buffer_phy[0,1,2] 0x%" B_PRIx32 ", 0x%"
-			B_PRIx32 " 0x%" B_PRIx32 "\n",
-			itd->buffer_phy[0], itd->buffer_phy[1], itd->buffer_phy[2]);
+			B_PRIx32 " 0x%" B_PRIx32 " (mult=%d)\n",
+			itd->buffer_phy[0], itd->buffer_phy[1], itd->buffer_phy[2], mult);

 		if (!LockIsochronous())
 			continue;
@@ -1346,17 +1403,79 @@ status_t
 EHCI::NotifyPipeChange(Pipe *pipe, usb_change change)
 {
 	TRACE("pipe change %d for pipe %p\n", change, pipe);
+
 	switch (change) {
-		case USB_CHANGE_CREATED:
+		case USB_CHANGE_CREATED: {
+			// For interrupt pipes, we create and keep a single queue head
+			// that will be reused for all transfers. This improves performance
+			// and reduces memory fragmentation.
+			// Note: Bulk and control pipes still create queue heads per-transfer
+			// because their transfer patterns are different.
+			if ((pipe->Type() & USB_OBJECT_INTERRUPT_PIPE) != 0) {
+				ehci_qh *queueHead = CreateQueueHead();
+				if (queueHead == NULL) {
+					TRACE_ERROR("failed to create queue head for interrupt pipe\n");
+					return B_NO_MEMORY;
+				}
+
+				status_t result = InitQueueHead(queueHead, pipe);
+				if (result != B_OK) {
+					FreeQueueHead(queueHead);
+					TRACE_ERROR("failed to init queue head for interrupt pipe\n");
+					return result;
+				}
+
+				// Link the queue head to the periodic schedule
+				result = LinkInterruptQueueHead(queueHead, pipe);
+				if (result != B_OK) {
+					FreeQueueHead(queueHead);
+					TRACE_ERROR("failed to link queue head for interrupt pipe\n");
+					return result;
+				}
+
+				pipe->SetControllerCookie(queueHead);
+				TRACE("created queue head %p for interrupt pipe %p\n",
+					queueHead, pipe);
+			}
+			break;
+		}
+
 		case USB_CHANGE_DESTROYED: {
-			// ToDo: we should create and keep a single queue head
-			// for all transfers to/from this pipe
+			// Clean up any queue head we created for this pipe
+			ehci_qh *queueHead = (ehci_qh *)pipe->ControllerCookie();
+			if (queueHead != NULL) {
+				// First cancel any pending transfers
+				CancelQueuedTransfers(pipe, true);
+
+				// Unlink from the schedule
+				UnlinkQueueHead(queueHead, &fFreeListHead);
+
+				// Let the cleanup thread free it after the controller
+				// has acknowledged the change
+				release_sem(fCleanupSem);
+
+				pipe->SetControllerCookie(NULL);
+				TRACE("destroyed queue head for pipe %p\n", pipe);
+			}
 			break;
 		}

 		case USB_CHANGE_PIPE_POLICY_CHANGED: {
-			// ToDo: for isochronous pipes we might need to adapt to new
-			// pipe policy settings here
+			// For interrupt pipes with a persistent queue head, we may need
+			// to update the queue head settings based on the new policy
+			ehci_qh *queueHead = (ehci_qh *)pipe->ControllerCookie();
+			if (queueHead != NULL
+					&& (pipe->Type() & USB_OBJECT_INTERRUPT_PIPE) != 0) {
+				// Reinitialize the queue head with updated settings
+				// The queue head is already linked, so we just update the
+				// endpoint characteristics if needed
+				status_t result = InitQueueHead(queueHead, pipe);
+				if (result != B_OK) {
+					TRACE_ERROR("failed to update queue head settings\n");
+					return result;
+				}
+				TRACE("updated queue head settings for pipe %p\n", pipe);
+			}
 			break;
 		}
 	}
@@ -1557,7 +1676,32 @@ EHCI::ControllerReset()
 status_t
 EHCI::LightReset()
 {
-	return B_ERROR;
+	// Light Host Controller Reset - resets state but preserves configuration
+	// EHCI Spec 2.3.1: When set, the Host Controller resets its internal
+	// pipelines, timers, counters, state machines, etc. to their initial value.
+	// Unlike HCRESET, it does not reset the PCI configuration or the root hub
+	// port registers.
+
+	uint32 command = ReadOpReg(EHCI_USBCMD);
+
+	// Check if Light Reset is supported (by verifying the controller responds)
+	WriteOpReg(EHCI_USBCMD, command | EHCI_USBCMD_LHCRESET);
+
+	// Wait for the reset to complete (bit clears when done)
+	int32 tries = 10;
+	while (ReadOpReg(EHCI_USBCMD) & EHCI_USBCMD_LHCRESET) {
+		snooze(1000);
+		if (tries-- <= 0) {
+			TRACE_ERROR("light reset timeout\n");
+			return B_TIMED_OUT;
+		}
+	}
+
+	// Wait a bit for the controller to stabilize
+	snooze(1000);
+
+	TRACE("light reset successful\n");
+	return B_OK;
 }


@@ -1636,9 +1780,20 @@ EHCI::InterruptPollThread(void *data)
 	EHCI *ehci = (EHCI *)data;

 	while (!ehci->fStopThreads) {
-		// TODO: this could be handled much better by only polling when there
-		// are actual transfers going on...
-		snooze(1000);
+		// Check if there are any transfers pending
+		// Use faster polling when there are active transfers,
+		// slower polling when idle to reduce CPU usage
+		bool hasTransfers = (ehci->fFirstTransfer != NULL)
+			|| (ehci->fFirstIsochronousTransfer != NULL);
+
+		if (hasTransfers) {
+			// Active transfers: poll every 1ms for responsive completions
+			snooze(1000);
+		} else {
+			// Idle: poll every 10ms to catch port status changes and
+			// any transfers that might have been added
+			snooze(10000);
+		}

 		cpu_status status = disable_interrupts();
 		ehci->Interrupt();
@@ -1805,22 +1960,117 @@ EHCI::CancelQueuedTransfers(Pipe *pipe, bool force)
 status_t
 EHCI::CancelQueuedIsochronousTransfers(Pipe *pipe, bool force)
 {
+	if (!LockIsochronous())
+		return B_ERROR;
+
+	struct transfer_entry {
+		isochronous_transfer_data*	transfer;
+		transfer_entry*				next;
+	};
+
+	transfer_entry *cancelList = NULL;
 	isochronous_transfer_data *current = fFirstIsochronousTransfer;
+	isochronous_transfer_data *previous = NULL;
+	bool found = false;

-	while (current) {
+	while (current != NULL) {
 		if (current->transfer->TransferPipe() == pipe) {
-			// TODO implement
+			found = true;

-			// TODO: Use the force paramater in order to avoid calling
-			// invalid callbacks
+			// Mark as inactive first to prevent FinishIsochronousTransfers
+			// from processing it
 			current->is_active = false;
+
+			// Unlink ITDs from the frame list
+			for (uint32 i = 0; i <= current->last_to_process; i++) {
+				ehci_itd *itd = current->descriptors[i];
+				if (itd != NULL && itd->prev != NULL) {
+					// Clear active status on all tokens to stop hardware
+					for (int j = 0; j < 8; j++) {
+						itd->token[j] &= ~(EHCI_ITD_STATUS_ACTIVE
+							<< EHCI_ITD_STATUS_SHIFT);
+					}
+
+					// Find which frame this ITD belongs to and unlink
+					for (uint32 frame = 0; frame < EHCI_VFRAMELIST_ENTRIES_COUNT;
+							frame++) {
+						if (fItdEntries[frame] != NULL) {
+							ehci_itd *check = fItdEntries[frame];
+							while (check != NULL) {
+								if (check == itd) {
+									UnlinkITDescriptors(itd,
+										&fItdEntries[frame]);
+									break;
+								}
+								check = check->next;
+							}
+						}
+					}
+				}
+			}
+
+			// Remove from the transfer list
+			if (previous != NULL)
+				previous->link = current->link;
+			else
+				fFirstIsochronousTransfer = current->link;
+
+			if (current == fLastIsochronousTransfer)
+				fLastIsochronousTransfer = previous;
+
+			// Add to cancel list for later processing outside the lock
+			transfer_entry *entry
+				= (transfer_entry *)malloc(sizeof(transfer_entry));
+			if (entry != NULL) {
+				entry->transfer = current;
+				entry->next = cancelList;
+				cancelList = entry;
+			}
+
+			// Move to next, but don't update previous since we removed current
+			current = (previous != NULL) ? previous->link
+				: fFirstIsochronousTransfer;
+		} else {
+			previous = current;
+			current = current->link;
 		}
+	}

-		current = current->link;
+	UnlockIsochronous();
+
+	// Process the cancel list outside the lock
+	while (cancelList != NULL) {
+		transfer_entry *next = cancelList->next;
+		isochronous_transfer_data *transfer = cancelList->transfer;
+
+		// Call the callback if not forcing
+		if (!force && transfer->transfer != NULL)
+			transfer->transfer->Finished(B_CANCELED, 0);
+
+		// Free descriptors
+		for (uint32 i = 0; i <= transfer->last_to_process; i++)
+			FreeDescriptor(transfer->descriptors[i]);
+
+		// Free the transfer data
+		delete[] transfer->descriptors;
+		delete transfer->transfer;
+		if (transfer->buffer_log != NULL) {
+			fStack->FreeChunk(transfer->buffer_log,
+				(phys_addr_t)transfer->buffer_phy, transfer->buffer_size);
+		}
+		delete transfer;
+
+		free(cancelList);
+		cancelList = next;
 	}

-	TRACE_ERROR("no isochronous transfer found!\n");
-	return B_ERROR;
+	if (!found) {
+		TRACE("no isochronous transfer found for pipe\n");
+		return B_OK;  // Not an error if there's nothing to cancel
+	}
+
+	TRACE("canceled isochronous transfers for pipe %p\n", pipe);
+	return B_OK;
 }


@@ -2150,6 +2400,14 @@ EHCI::FinishIsochronousTransfers()

 			ehci_itd *itd = fItdEntries[currentFrame];

+			// Safety check: ensure itd is valid before accessing
+			if (itd == NULL) {
+				TRACE_ERROR("FinishIsochronousTransfers: NULL itd at frame %"
+					B_PRIu32 "\n", currentFrame);
+				currentFrame = (currentFrame + 1) % EHCI_VFRAMELIST_ENTRIES_COUNT;
+				continue;
+			}
+
 			TRACE("FinishIsochronousTransfers itd %p phy 0x%" B_PRIx32
 				" prev (%p/0x%" B_PRIx32 ") at frame %" B_PRId32 "\n", itd,
 				itd->this_phy, itd->prev, itd->prev != NULL
@@ -2159,7 +2417,19 @@ EHCI::FinishIsochronousTransfers()
 				continue;

 			// Process the frame till it has isochronous descriptors in it.
-			while (!(itd->next_phy & EHCI_ITEM_TERMINATE) && itd->prev != NULL) {
+			// Check itd->prev != NULL to ensure we don't process base iTDs
+			while (itd != NULL
+				&& !(itd->next_phy & EHCI_ITEM_TERMINATE)
+				&& itd->prev != NULL) {
+
+				// Validate last_token before using as array index (must be 0-7)
+				uint32 lastToken = itd->last_token;
+				if (lastToken > 7) {
+					TRACE_ERROR("FinishIsochronousTransfers: invalid last_token %"
+						B_PRIu32 " for itd %p, clamping to 7\n", lastToken, itd);
+					lastToken = 7;
+				}
+
 				TRACE("FinishIsochronousTransfers checking itd %p last_token"
 					" %" B_PRId32 "\n", itd, itd->last_token);
 				TRACE("FinishIsochronousTransfers tokens 0x%" B_PRIx32 " 0x%"
@@ -2167,10 +2437,15 @@ EHCI::FinishIsochronousTransfers()
 					" 0x%" B_PRIx32 " 0x%" B_PRIx32 " 0x%" B_PRIx32 "\n",
 					itd->token[0], itd->token[1], itd->token[2], itd->token[3],
 					itd->token[4], itd->token[5], itd->token[6], itd->token[7]);
-				if (((itd->token[itd->last_token] >> EHCI_ITD_STATUS_SHIFT)
+				if (((itd->token[lastToken] >> EHCI_ITD_STATUS_SHIFT)
 					& EHCI_ITD_STATUS_ACTIVE) == EHCI_ITD_STATUS_ACTIVE) {
 					TRACE("FinishIsochronousTransfers unprocessed active itd\n");
 				}
+
+				// CRITICAL: Save prev pointer BEFORE unlinking, as UnlinkITDescriptors
+				// may modify the list structure
+				ehci_itd *prevItd = itd->prev;
+
 				UnlinkITDescriptors(itd, &fItdEntries[currentFrame]);

 				// Process the transfer if we found the last descriptor
@@ -2210,7 +2485,8 @@ EHCI::FinishIsochronousTransfers()

 					transfer->transfer->Finished(status, actualLength);

-					itd = itd->prev;
+					// Use saved prev pointer for next iteration
+					itd = prevItd;

 					for (uint32 i = 0; i <= transfer->last_to_process; i++)
 						FreeDescriptor(transfer->descriptors[i]);
@@ -2226,7 +2502,8 @@ EHCI::FinishIsochronousTransfers()
 					transferDone = true;
 				} else {
 					TRACE("FinishIsochronousTransfers not end of transfer\n");
-					itd = itd->prev;
+					// Use saved prev pointer for next iteration
+					itd = prevItd;
 				}
 			}

@@ -2681,12 +2958,27 @@ EHCI::CreateDescriptor(size_t bufferSize, uint8 pid)
 	}

 	addr_t physicalBase = (addr_t)physicalAddress;
-	result->buffer_phy[0] = physicalBase;
+	result->buffer_phy[0] = (uint32)physicalBase;
+#ifdef B_HAIKU_64_BIT
+	if (fSupports64Bit)
+		result->ext_buffer_phy[0] = (uint32)(physicalBase >> 32);
+	else
+		result->ext_buffer_phy[0] = 0;
+#else
 	result->ext_buffer_phy[0] = 0;
+#endif
+
 	for (int32 i = 1; i < 5; i++) {
 		physicalBase += B_PAGE_SIZE;
-		result->buffer_phy[i] = physicalBase & EHCI_QTD_PAGE_MASK;
+		result->buffer_phy[i] = (uint32)(physicalBase & EHCI_QTD_PAGE_MASK);
+#ifdef B_HAIKU_64_BIT
+		if (fSupports64Bit)
+			result->ext_buffer_phy[i] = (uint32)(physicalBase >> 32);
+		else
+			result->ext_buffer_phy[i] = 0;
+#else
 		result->ext_buffer_phy[i] = 0;
+#endif
 	}

 	return result;
@@ -2868,6 +3160,17 @@ EHCI::LinkSITDescriptors(ehci_sitd *sitd, ehci_sitd **_last)
 void
 EHCI::UnlinkITDescriptors(ehci_itd *itd, ehci_itd **last)
 {
+	// Safety check: itd and itd->prev must be valid
+	if (itd == NULL) {
+		TRACE_ERROR("UnlinkITDescriptors: NULL itd!\n");
+		return;
+	}
+	if (itd->prev == NULL) {
+		// This is a base iTD from the framelist, should not be unlinked
+		TRACE_ERROR("UnlinkITDescriptors: itd %p has NULL prev, skipping\n", itd);
+		return;
+	}
+
 	itd->prev->next_phy = itd->next_phy;
 	itd->prev->next = itd->next;
 	if (itd->next != NULL)
@@ -3058,68 +3361,89 @@ EHCI::ReadIsochronousDescriptorChain(isochronous_transfer_data *transfer)

 	for (uint32 i = 0; i <= transfer->last_to_process; i++) {
 		ehci_itd *itd = transfer->descriptors[i];
-		for (uint32 j = 0; j <= itd->last_token
-			&& packet < isochronousData->packet_count; j++) {
-
-			size_t bufferSize = (itd->token[j] >> EHCI_ITD_TLENGTH_SHIFT)
-				& EHCI_ITD_TLENGTH_MASK;
-			if (((itd->token[j] >> EHCI_ITD_STATUS_SHIFT)
-				& EHCI_ITD_STATUS_MASK) != 0) {
-				bufferSize = 0;
-			}
-			isochronousData->packet_descriptors[packet].actual_length
-				= bufferSize;
-
-			if (bufferSize > 0)
-				isochronousData->packet_descriptors[packet].status = B_OK;
-			else
-				isochronousData->packet_descriptors[packet].status = B_ERROR;

-			totalLength += bufferSize;
-
-			size_t offset = bufferOffset;
-			size_t skipSize = packetSize - bufferSize;
-			while (bufferSize > 0) {
-				size_t length = min_c(bufferSize,
-					vector[vectorIndex].length - vectorOffset);
-				status_t status = generic_memcpy(
-					vector[vectorIndex].base + vectorOffset, physical,
-					(generic_addr_t)transfer->buffer_log + bufferOffset, false, length);
-				ASSERT_ALWAYS(status == B_OK);
-
-				offset += length;
-				vectorOffset += length;
-				bufferSize -= length;
+		// Extract mult from buffer_phy[2] to know how many transactions per packet
+		uint8 mult = ((itd->buffer_phy[2] >> EHCI_ITD_MUL_SHIFT)
+			& EHCI_ITD_MUL_MASK);
+		if (mult == 0)
+			mult = 1;  // mult field of 0 means 1 transaction
+
+		TRACE("ReadIsochronousDescriptorChain: itd %p, mult=%d, last_token=%d\n",
+			itd, mult, itd->last_token);
+
+		// Process transactions in groups of 'mult' (one group = one microframe = one packet)
+		uint32 slot = 0;
+		while (slot <= itd->last_token && packet < isochronousData->packet_count) {
+			// Accumulate data from 'mult' transactions for this packet
+			size_t packetActualLength = 0;
+			status_t packetStatus = B_OK;
+			size_t packetBufferStart = bufferOffset;
+
+			for (uint8 t = 0; t < mult && slot <= itd->last_token; t++, slot++) {
+				size_t transactionLength = (itd->token[slot] >> EHCI_ITD_TLENGTH_SHIFT)
+					& EHCI_ITD_TLENGTH_MASK;
+				uint8 transactionStatus = (itd->token[slot] >> EHCI_ITD_STATUS_SHIFT)
+					& EHCI_ITD_STATUS_MASK;
+
+				TRACE("ReadIsochronousDescriptorChain: slot %d, len=%zu, status=0x%x\n",
+					slot, transactionLength, transactionStatus);
+
+				if (transactionStatus != 0) {
+					// Transaction had an error
+					packetStatus = B_ERROR;
+					transactionLength = 0;
+				}

-				if (vectorOffset >= vector[vectorIndex].length) {
-					if (++vectorIndex >= vectorCount) {
-						TRACE("read isodescriptor chain (%ld bytes, no more "
-							"vectors)\n", totalLength);
-						return totalLength;
+				packetActualLength += transactionLength;
+
+				// Copy data from this transaction to user buffer
+				size_t copyRemaining = transactionLength;
+				while (copyRemaining > 0 && vectorIndex < vectorCount) {
+					size_t length = min_c(copyRemaining,
+						vector[vectorIndex].length - vectorOffset);
+					status_t status = generic_memcpy(
+						vector[vectorIndex].base + vectorOffset, physical,
+						(generic_addr_t)transfer->buffer_log + bufferOffset, false, length);
+					ASSERT_ALWAYS(status == B_OK);
+
+					vectorOffset += length;
+					bufferOffset += length;
+					copyRemaining -= length;
+
+					if (vectorOffset >= vector[vectorIndex].length) {
+						if (++vectorIndex >= vectorCount) {
+							break;
+						}
+						vectorOffset = 0;
 					}
-
-					vectorOffset = 0;
 				}
 			}

-			// skip to next packet offset
-			while (skipSize > 0) {
+			// Set the packet descriptor for this microframe
+			isochronousData->packet_descriptors[packet].actual_length = packetActualLength;
+			isochronousData->packet_descriptors[packet].status = packetStatus;
+
+			TRACE("ReadIsochronousDescriptorChain: packet %d actual_length=%zu status=%d\n",
+				packet, packetActualLength, packetStatus);
+
+			totalLength += packetActualLength;
+
+			// Skip any unused space in this packet's buffer allocation
+			size_t skipSize = packetSize - (bufferOffset - packetBufferStart);
+			while (skipSize > 0 && vectorIndex < vectorCount) {
 				size_t length = min_c(skipSize,
 					vector[vectorIndex].length - vectorOffset);
 				vectorOffset += length;
+				bufferOffset += length;
 				skipSize -= length;
 				if (vectorOffset >= vector[vectorIndex].length) {
 					if (++vectorIndex >= vectorCount) {
-						TRACE("read isodescriptor chain (%ld bytes, no more "
-							"vectors)\n", totalLength);
-						return totalLength;
+						break;
 					}
-
 					vectorOffset = 0;
 				}
 			}

-			bufferOffset += packetSize;
 			if (bufferOffset >= transfer->buffer_size)
 				return totalLength;

diff --git a/src/add-ons/kernel/busses/usb/ehci.h b/src/add-ons/kernel/busses/usb/ehci.h
index a5eea1f2..fd7a6dcc 100644
--- a/src/add-ons/kernel/busses/usb/ehci.h
+++ b/src/add-ons/kernel/busses/usb/ehci.h
@@ -262,6 +262,9 @@ inline	uint32						ReadCapReg32(uint32 reg);
 		thread_id					fInterruptPollThread;
 		uint32						fIRQ;
 		bool						fUseMSI;
+
+		// 64-bit addressing support
+		bool						fSupports64Bit;
 };


diff --git a/src/add-ons/kernel/busses/usb/ehci_hardware.h b/src/add-ons/kernel/busses/usb/ehci_hardware.h
index 13483038..5a3d4d20 100644
--- a/src/add-ons/kernel/busses/usb/ehci_hardware.h
+++ b/src/add-ons/kernel/busses/usb/ehci_hardware.h
@@ -108,6 +108,7 @@
 #define EHCI_LEGSUP_OSOWNED		(1 << 24)	// OS Owned Semaphore
 #define EHCI_LEGSUP_BIOSOWNED	(1 << 16)	// BIOS Owned Semaphore

+#define EHCI_HCCPARAMS_64BIT	(1 << 0)	// 64-bit Addressing Capability
 #define EHCI_HCCPARAMS_FPLC		(1 << 19)	// 32 Frames Period List
 #define EHCI_HCCPARAMS_PPCEC	(1 << 18)	// Per-Port Change Event
 #define EHCI_HCCPARAMS_LPM		(1 << 17)	// Link Power Management
